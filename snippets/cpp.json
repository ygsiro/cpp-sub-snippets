{
  "#if": {
    "prefix": "#if",
    "body": ["#if ${1: expression}", "$0", "#endif // ${1: expression}"],
    "description": "#if directive"
  },
  "#elif": {
    "prefix": "#elif",
    "body": "#elif ${1: expression}",
    "description": "#elif directive"
  },
  "#else": {
    "prefix": "#else",
    "body": "#else",
    "description": "#else directive"
  },
  "#define": {
    "prefix": "#define",
    "body": "#define ${1: def}",
    "description": "#define directive"
  },
  "#ifdef": {
    "prefix": "#ifdef",
    "body": [
      "#ifdef ${1: expression}",
      "$0",
      "#endif // ${1: expression}"
    ],
    "description": "#ifdef directive"
  },
  "#ifndef": {
    "prefix": "#ifndef",
    "body": [
      "#ifndef ${1: expression}",
      "$0",
      "#endif // ${1: expression}"
    ],
    "description": "#ifdef directive"
  },
  "#inc-g": {
    "prefix": ["#include-guards", "#hdr"],
    "body": [
      "#ifndef ${1:${TM_FILENAME/(.+)\\.(.+)/${1:/upcase}_${2:/upcase}/}}",
      "#define ${1:${TM_FILENAME/(.+)\\.(.+)/${1:/upcase}_${2:/upcase}/}}",
      "$0",
      "#endif // ${1:${TM_FILENAME/(.+)\\.(.+)/${1:/upcase}_${2:/upcase}/}}"
    ],
    "description": "include guards."
  },
  "#include": {
    "prefix": ["#include", "#inc"],
    "body": ["#include "],
    "description": "#include directive"
  },
  "has-include":{
    "prefix": "has-include",
    "body": [
      "#if __has_include(${1:headder})",
      "$0",
      "#else",
      "#endif"
    ],
    "description": "C++17: __has_include"
  },

  "noreturn": {
    "prefix": ["noreturn"],
    "body": "[[noreturn]]$0",
    "description": "C++11: noreturn attribute"
  },
  "carries_dependency": {
    "prefix": ["carries_dependency"],
    "body": "[[carries_dependency]]$0",
    "description": "C++11: carries_dependency attribute"
  },

  "deprecated": {
    "prefix": ["deprecated"],
    "body": "[[deprecated(\"${1: description}\")]]$0",
    "description": "C++14: deprecated attribute"
  },
  "nodiscard": {
    "prefix": ["nodiscard"],
    "body": "[[nodiscard${1:(\"${2: C++20 description}\")}]]$0",
    "description": "C++14: nodiscard attribute"
  },

  "maybe_unused": {
    "prefix": ["maybe_unused"],
    "body": "[[maybe_unused]]$0",
    "description": "C++17: maybe_unused attribute"
  },
  "fallthrough": {
    "prefix": ["fallthrough"],
    "body": "[[fallthrough]]$0",
    "description": "C++17: fallthrough attribute"
  },

  "no_unique_address": {
    "prefix": ["no_unique_address"],
    "body": "[[no_unique_address]]$0",
    "description": "C++20: no_unique_address attribute"
  },
  "likely": {
    "prefix": ["likely"],
    "body": "[[likely]]$0",
    "description": "C++20: likely attribute"
  },
  "unlikely": {
    "prefix": ["unlikely"],
    "body": "[[unlikely]]$0",
    "description": "C++20: unlikely attribute"
  },

  "concept": {
    "prefix": "concept",
    "body": [
      "template <class T>",
      "concept ${1: concept_name} = requires (T& ${2:x}){",
      "  $0",
      "};"
    ],
    "description": "C++20: concept"
  },

  "static_assert": {
    "prefix": ["static_assert", "sta"],
    "body": "static_assert(${1: expression}${2:, \"${3:description(C++17: optional)}\"});$0",
    "description": "C++20: static_assert attribute"
  },

  "ifc": {
    "prefix": ["if-constexpr", "ifc"],
    "body": ["if constexpr(${1: expression}){", "$0", "}"],
    "description": "C++17: constexpr if."
  },

  "alignas":{
    "prefix": "alignas",
    "body": "alignas(${1: byte})",
    "description": "C++11: alignas"
  },

  "alignof":{
    "prefix": "alignof",
    "body": "alignof(${1: type})",
    "description": "C++11: alignof"
  },

  "using":{
    "prefix": "using new name",
    "body": "using ${1:identifier} = ${2:type};$0",
    "description": "C++11: using directive"
  },
  "tmp_using":{
    "prefix": "template using new name",
    "body": [
      "template<${1|class,typename|} ${2:T}>",
      "using ${3:identifier} = ${4:type}<${2:T}>;$0"
    ],
    "description": "C++11: template using directive"
  },
  "user_defined_literal_integral":{
    "prefix": ["user defined literal integral", "udli"],
    "body": [
      "${1:ReturnType} operator \"\" _${2:suffix}(unsigned long long ${3:count}){",
      "\treturn ${1:ReturnType}();$0",
      "}"
    ],
    "description": "C++11: Literal operator for user-defined INTEGRAL literal"
  },
  "user_defined_literal_floating":{
    "prefix": ["user defined literal floating", "udlf"],
    "body": [
      "${1:ReturnType} operator \"\" _${2:suffix}(long double ${3:count}){",
      "\treturn ${1:ReturnType}();$0",
      "}"
    ],
    "description": "C++11: Literal operator for user-defined FLOATING literal"
  },
  "user_defined_literal_character":{
    "prefix": ["user defined literal character", "udlc"],
    "body": [
      "${1:ReturnType} operator \"\" _${2:suffix}(${3|char,wchar_t,char16_t,char32_t|} ${4:str}){",
      "\treturn ${1:ReturnType}();$0",
      "}"
    ],
    "description": "C++11: Literal operator for user-defined CHARACTER literal"
  },
  "user_defined_literal_string":{
    "prefix": ["user defined literal string", "udls"],
    "body": [
      "${1:ReturnType} operator \"\" _${2:suffix}(${3|const char*,const wchar_t*,const char16_t*,const char32_t*|} ${4:str}, size_t ${5:N}){",
      "\treturn ${1:ReturnType}();$0",
      "}"
    ],
    "description": "C++11: Literal operator for user-defined STRING literal"
  },
  "user_defined_literal_raw":{
    "prefix": ["user defined literal raw", "udlr"],
    "body": [
      "${1:ReturnType} operator \"\" _${2:suffix}(const char* ${3:str}){",
      "\treturn ${1:ReturnType}();$0",
      "}"
    ],
    "description": "C++11: Literal operator for user-defined STRING literal"
  },
  "user_defined_literal_template":{
    "prefix": ["user defined literal template", "udlt"],
    "body": [
      "template<char... ${1:S}>",
      "${2:ReturnType} operator \"\" _${3:suffix}(){",
      "\treturn ${2:ReturnType}();$0",
      "}"
    ],
    "description": "C++11: Literal operator template"
  }
}

{
  "#if": {
    "prefix": "#if",
    "body": ["#if ${1: expression}", "$0", "#endif // ${1: expression}"],
    "description": "#if directive"
  },
  "#elif": {
    "prefix": "#elif",
    "body": "#elif ${1: expression}",
    "description": "#elif directive"
  },
  "#else": {
    "prefix": "#else",
    "body": "#else",
    "description": "#else directive"
  },
  "#define": {
    "prefix": "#define",
    "body": "#define ${1: def}",
    "description": "#define directive"
  },
  "#ifdef": {
    "prefix": "#ifdef",
    "body": ["#ifdef ${1: expression}", "$0", "#endif // ${1: expression}"],
    "description": "#ifdef directive"
  },
  "#ifndef": {
    "prefix": "#ifndef",
    "body": ["#ifndef ${1: expression}", "$0", "#endif // ${1: expression}"],
    "description": "#ifdef directive"
  },
  "#inc-g": {
    "prefix": ["#include-guards", "#hdr"],
    "body": [
      "#ifndef ${TM_FILENAME/(?:(\\w+)(\\.)?)/${1:/upcase}${2:+_}/gi}",
      "#define ${TM_FILENAME/(?:(\\w+)(\\.)?)/${1:/upcase}${2:+_}/gi}",
      "$0",
      "#endif // ${TM_FILENAME/(?:(\\w+)(\\.)?)/${1:/upcase}${2:+_}/gi}"
    ],
    "description": "include guards."
  },
  "#include": {
    "prefix": ["#include", "#inc"],
    "body": ["#include "],
    "description": "#include directive"
  },
  "has-include": {
    "prefix": "has-include",
    "body": ["#if __has_include(${1:headder})", "$0", "#else", "#endif"],
    "description": "C++17: __has_include"
  },

  "noreturn": {
    "prefix": ["noreturn"],
    "body": "[[noreturn]]$0",
    "description": "C++11: noreturn attribute"
  },
  "carries_dependency": {
    "prefix": ["carries_dependency"],
    "body": "[[carries_dependency]]$0",
    "description": "C++11: carries_dependency attribute"
  },

  "deprecated": {
    "prefix": ["deprecated"],
    "body": "[[deprecated(\"${1: description}\")]]$0",
    "description": "C++14: deprecated attribute"
  },
  "nodiscard": {
    "prefix": ["nodiscard"],
    "body": "[[nodiscard${1:(\"${2: C++20 description}\")}]]$0",
    "description": "C++14: nodiscard attribute"
  },

  "maybe_unused": {
    "prefix": ["maybe_unused"],
    "body": "[[maybe_unused]]$0",
    "description": "C++17: maybe_unused attribute"
  },
  "fallthrough": {
    "prefix": ["fallthrough"],
    "body": "[[fallthrough]]$0",
    "description": "C++17: fallthrough attribute"
  },

  "no_unique_address": {
    "prefix": ["no_unique_address"],
    "body": "[[no_unique_address]]$0",
    "description": "C++20: no_unique_address attribute"
  },
  "likely": {
    "prefix": ["likely"],
    "body": "[[likely]]$0",
    "description": "C++20: likely attribute"
  },
  "unlikely": {
    "prefix": ["unlikely"],
    "body": "[[unlikely]]$0",
    "description": "C++20: unlikely attribute"
  },

  "concept": {
    "prefix": "concept",
    "body": [
      "template <class T>",
      "concept ${1: concept_name} = requires (T& ${2:x}){",
      "  $0",
      "};"
    ],
    "description": "C++20: concept"
  },

  "static_assert": {
    "prefix": ["static_assert", "sta"],
    "body": "static_assert(${1: expression}${2:, \"${3:description(C++17: optional)}\"});$0",
    "description": "C++20: static_assert attribute"
  },

  "ifc": {
    "prefix": ["if-constexpr", "ifc"],
    "body": ["if constexpr(${1: expression}){", "$0", "}"],
    "description": "C++17: constexpr if."
  },

  "alignas": {
    "prefix": "alignas",
    "body": "alignas(${1: byte})",
    "description": "C++11: alignas"
  },

  "alignof": {
    "prefix": "alignof",
    "body": "alignof(${1: type})",
    "description": "C++11: alignof"
  },

  "using": {
    "prefix": "using new name",
    "body": "using ${1:identifier} = ${2:type};$0",
    "description": "C++11: using directive"
  },
  "tmp_using": {
    "prefix": "template using new name",
    "body": [
      "template<${1|class,typename|} ${2:T}>",
      "using ${3:identifier} = ${4:type}<${2:T}>;$0"
    ],
    "description": "C++11: template using directive"
  },
  "user_defined_literal_integral": {
    "prefix": ["user defined literal integral", "udli"],
    "body": [
      "${1:ReturnType} operator \"\" _${2:suffix}(unsigned long long ${3:count}){",
      "\treturn ${1:ReturnType}();$0",
      "}"
    ],
    "description": "C++11: Literal operator for user-defined INTEGRAL literal"
  },
  "user_defined_literal_floating": {
    "prefix": ["user defined literal floating", "udlf"],
    "body": [
      "${1:ReturnType} operator \"\" _${2:suffix}(long double ${3:count}){",
      "\treturn ${1:ReturnType}();$0",
      "}"
    ],
    "description": "C++11: Literal operator for user-defined FLOATING literal"
  },
  "user_defined_literal_character": {
    "prefix": ["user defined literal character", "udlc"],
    "body": [
      "${1:ReturnType} operator \"\" _${2:suffix}(${3|char,wchar_t,char16_t,char32_t|} ${4:str}){",
      "\treturn ${1:ReturnType}();$0",
      "}"
    ],
    "description": "C++11: Literal operator for user-defined CHARACTER literal"
  },
  "user_defined_literal_string": {
    "prefix": ["user defined literal string", "udls"],
    "body": [
      "${1:ReturnType} operator \"\" _${2:suffix}(${3|const char*,const wchar_t*,const char16_t*,const char32_t*|} ${4:str}, size_t ${5:N}){",
      "\treturn ${1:ReturnType}();$0",
      "}"
    ],
    "description": "C++11: Literal operator for user-defined STRING literal"
  },
  "user_defined_literal_raw": {
    "prefix": ["user defined literal raw", "udlr"],
    "body": [
      "${1:ReturnType} operator \"\" _${2:suffix}(const char* ${3:str}){",
      "\treturn ${1:ReturnType}();$0",
      "}"
    ],
    "description": "C++11: Literal operator for user-defined STRING literal"
  },
  "user_defined_literal_template": {
    "prefix": ["user defined literal template", "udlt"],
    "body": [
      "template<char... ${1:S}>",
      "${2:ReturnType} operator \"\" _${3:suffix}(){",
      "\treturn ${2:ReturnType}();$0",
      "}"
    ],
    "description": "C++11: Literal operator template"
  },
  "coroutine_generator": {
    "prefix": ["coroutine generator class"],
    "body": [
      "class ${1:generator}{",
      "public:",
      "  struct promise_type;",
      "  using handle = std::coroutine_handle<promise_type>;",
      "  struct promise_type{",
      "    ${3:T} ${4:current_value};",
      "    static auto get_return_object_on_allocation_failure() { return ${1:generator}{nullptr}; }",
      "    auto get_return_object() { return ${1:generator}{handle::from_promise(*this)}; }",
      "    auto initial_suspend() { return std::suspend_always{}; }",
      "    auto final_suspend() noexcept { return std::suspend_always{}; }",
      "    void unhandled_exception() { std::terminate(); }",
      "    void ${5|return_void,return_value|}() {$0}",
      "    auto yield_value(${3:T} value){",
      "      ${4:current_value} = value;",
      "      return std::suspend_always{};",
      "    }",
      "  };",
      "",
      "  ${1:generator}(${1:generator} const&) = delete;",
      "  ${1:generator}(${1:generator}&& rhs)noexcept",
      "    :${2:coro_}(rhs.${2:coro_}){rhs.${2:coro_} = nullptr;}",
      "  ~${1:generator}(){if(${2:coro_}) ${2:coro_}.destroy();}",
      "  bool move_next() { return ${2:coro_}? (${2:coro_}.resume(), !${2:coro_}.done()) : false; }",
      "  ${3: T} ${4:current_value}(){return ${2:coro_}.promise().${4:current_value}; }",
      "private:",
      "  ${1:generator}(handle h):${2:coro_}(h){}",
      "  handle ${2:coro_};",
      "};"
    ],
    "description": "C++20: Coroutine generator class"
  },
  "attribute_cpp11": {
    "prefix": "attr11",
    "body": ["[[${1|noreturn,carries_dependency|}]]"],
    "description": "C++11 Attribute"
  },
  "attribute_cpp14": {
    "prefix": "attr14",
    "body": ["[[${1|noreturn,carries_dependency,deprecated(\"reason\")|}]]"],
    "description": "C++14 Attribute"
  },
  "attribute_cpp17": {
    "prefix": "attr17",
    "body": [
      "[[${1|noreturn,carries_dependency,deprecated(\"reason\"),maybe_unused,nodiscard,fallthrough|}]]"
    ],
    "description": "C++17 Attribute"
  },
  "attribute_cpp20": {
    "prefix": "attr20",
    "body": [
      "[[${1|noreturn,carries_dependency,deprecated(\"reason\"),maybe_unused,nodiscard(\"optional: reason\"),fallthrough,no_unique_address,likely,unlikely|}]]"
    ],
    "description": "C++20 Attribute. It is optional to state the reason for the nodiscard."
  }
}
